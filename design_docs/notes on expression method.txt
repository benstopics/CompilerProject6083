Expression can be organized into depths:
expression=0
arithOp=1
relation=2
term=3
factor=4

Was going to approach the expression production sets the same as the rest of the parsing methods, but realized that they all contain similarities. After abstracting those similarities, I designed a single expression parsing method which I believe to be more elegant.

First, expressions begin with one factor. Then, attempts to find operator for the specified depth. If found, match another factor (keeping type in mind). At end, decrement depth and call the expression method again. Lower depths should not attempt to find first factor in expression, except when calling self.parse_expression(ttype,4) to match factor where open paran is found and therefore self.parse_expression(ttype,0) is called to match the "`(` <expression> `)`" production of <factor>.

For code generation, will need to keep track of the temp var which contains the results of the expression operations from calling the parsing method. Therefore, parse_expression should return a string value of that last temp var. Then the caller of the original expression parsing method can figure out what to do with the final temp var which represents the results of the expression operations parsed.

Casting: to make it easy, emitter should contain methods for generating code that casts between compatible types (integer->bool and integer<-->float) given an LLVM variable.

So then the question is what semantic analysis will do, and the answer is that it will keep track of scope, temp var count, symbol table, global variables, etc., therefore it will be a local instance while the emitter will be a static class containing the static code generation methods.