Call semantic analysis methods simultaneously with parser (semantic analyzer generates IR but does not send to emitter)
Because semantics is being checked simultaneously with parser, error handler can output semantic errors with the lexer's character log at the time the token is being parsed, allowing for visual underlining of error token.

Also, make sure global variables/procedures can only be called in outer scope

IR Generation:

loops
assignment statements
procedure calls
if statements
return statements

observations:
- Loop is preceded by an assignment statement which can be separated from the loop class

**Loop
	Loop = Expression test ; Statement body
	The abstract class Loop has two components, a test which is a member of the abstract class Expression, and a body which is a member of an abstract class Statement

**Nice by-product: If parsing abstract syntax in a language like Java, it makes sense to actually define a class for each abstract syntactic class, e.g.
	class Loop extends Statement {
		Expression test;
		Statement body;
	}

In this way, we create an intermediate representation, or a new type of AST for semantic purposes which instead of a token node it is a semantic class node.

Example workflow:

a := true;

ID found:
- If lookahead is assignment, check to see if the variable is declared
- If lookahead is bracket, look semantic check expression for integer value

For semantic analysis class coding methods, start with lowest level productions and branch out. Expressions must be first.

EMITTER WORKING WITH SEMANTIC ANALYZER: When semantic analyzer enters or leaves scope, Emitter pops or pushes local temporary.

NO! instead, semantic analyzer checks expression tokens in real time to allow detailed error reporting.
Once semantically checked, TokenNodes returned until they reach a production which warrants an abstract class.
For example, assignment statement.  Once expression TokenNode is acquired which has been checked for semantic correctness,
	parser method parseAssignmentStatement builds an instance of the abstract class AssignmentStatement, which also includes
	an instance of the Expression abstract class as an attribute.  In fact, if each abstract class takes a node as an argument
	and builds the instance based upon nodes from the AST generated by the parser, this tree of abstract class instances would
	be considered IR.  This could be taken by the Emitter as an argument to generate the target language.
Implications: All abstract class constructors may only take one argument as input, which is a TokenNode from the parser's AST.

6/6/2015:
 - Once all IR classes complete, finish semantic methods and their callings from parser.
 - All abstract classes should probably have a print method. Simply go through the abstractclass package and make sure they all have one.
 - What semantic methods could do is give the abstract class back after it has been checked
 - Parameter and Argument are different in that a Parameter is defined in the procedure header and argument is defined in procedure call.
 - Need to find way to check if Expression is a lone variable name.
 - Need to rename checkKey overloading methods to something more specific (checkDestination, checkProcedure, etc)
 
6/7/2015:
 - Leave type checking to parseExpression() and derived methods. Add "type" attribute to ExpressionNode.
 - Save commented out evaluateExpression() method in SemanticAnalyzer class. Could borrow logic for code generation.
 
6/8/2015
 - Only allow bitwise for integers
